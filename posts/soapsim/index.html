<!doctype html><html lang=en><head><title>Simulating soapy water :: The Tymscar Blog</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Exploring the fascinating world of simulating soapy water using Rust and WASM"><meta name=keywords content="web,wasm,rust,javascript,development"><meta name=robots content="noodp"><link rel=canonical href=/posts/soapsim/><link rel=stylesheet href=/css/buttons.min.86f6b4c106b6c6eb690ae5203d36b442c1f66f718ff4e8164fa86cf6c61ad641.css><link rel=stylesheet href=/css/code.min.d529ea4b2fb8d34328d7d31afc5466d5f7bc2f0bc9abdd98b69385335d7baee4.css><link rel=stylesheet href=/css/fonts.min.5bb7ed13e1d00d8ff39ea84af26737007eb5051b157b86fc24487c94f3dc8bbe.css><link rel=stylesheet href=/css/footer.min.eb8dfc2c6a7eafa36cd3ba92d63e69e849e2200e0002a228d137f236b09ecd75.css><link rel=stylesheet href=/css/gist.min.a751e8b0abe1ba8bc53ced52a38b19d8950fe78ca29454ea8c2595cf26aad5c0.css><link rel=stylesheet href=/css/header.min.75c7eb0e2872d95ff48109c6647d0223a38db52e2561dd87966eb5fc7c6bdac6.css><link rel=stylesheet href=/css/main.min.36833afd348409fc6c3d09d0897c5833d9d5bf1ff31f5e60ea3ee42ce2b1268c.css><link rel=stylesheet href=/css/menu.min.3c17467ebeb3d38663dce68f71f519901124fa5cbb4519b2fb0667a21e9aca39.css><link rel=stylesheet href=/css/pagination.min.bbb986dbce00a5ce5aca0504b7925fc1c581992a4bf57f163e5d69cc1db7d836.css><link rel=stylesheet href=/css/post.min.e6dddd258e64c83e05cec0cd49c05216742d42fc8ecbfbe6b67083412b609bd3.css><link rel=stylesheet href=/css/syntax.min.a0773cce9310cb6d8ed23e50f005448facf29a53001b57e038828daa466b25c0.css><link rel=stylesheet href=/css/terminal.min.e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855.css><link rel=stylesheet href=/css/terms.min.b81791663c3790e738e571cdbf802312390d30e4b1d8dc9d814a5b5454d0ac11.css><link rel=stylesheet href=/style.css><link rel="shortcut icon" href=/img/favicon/favicon.ico><link rel=apple-touch-icon href=/apple-touch-icon.png><meta name=twitter:card content="summary"><meta name=twitter:site content="google.com"><meta name=twitter:creator content="tymscar"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="og:title" content="Simulating soapy water"><meta property="og:description" content="Exploring the fascinating world of simulating soapy water using Rust and WASM"><meta property="og:url" content="/posts/soapsim/"><meta property="og:site_name" content="The Tymscar Blog"><meta property="og:image" content="/img/favicon/favicon.ico"><meta property="og:image:width" content="1200"><meta property="og:image:height" content="627"><meta property="article:published_time" content="2024-04-04 12:00:00 +0000 UTC"></head><body><div class="container center"><header class=header><div class=header__inner><div class=header__logo><a href=/><div class=logo>Tymscar</div></a></div></div></header><div class=content><article class=post><h1 class=post-title><a href=/posts/soapsim/>Simulating soapy water</a></h1><div class=post-meta><time class=post-date>2024-04-04</time><span class=post-author>Oscar Molnar</span><span class=post-reading-time>4 min read (769 words)</span></div><span class=post-tags>#<a href=/tags/web/>web</a>&nbsp;
#<a href=/tags/wasm/>wasm</a>&nbsp;
#<a href=/tags/rust/>rust</a>&nbsp;
#<a href=/tags/javascript/>javascript</a>&nbsp;
#<a href=/tags/development/>development</a>&nbsp;</span><div class=post-content><div><p>Do you ever just scroll mindlessly online and stumble upon a satisfying video about physics and you can&rsquo;t help but have that urge to reproduce it in code?</p><p>No, just me? Well perhaps this blogpost isn&rsquo;t for you then. Otherwise, buckle up!</p><p>The experiment that caught my eye this time around was this video of a plate of water, with some pepper sprinkled on top uniformly, that when touched with a soapy finger, makes the pepper repel.</p><div style=position:relative;padding-bottom:56.25%;height:0;overflow:hidden><iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share; fullscreen" loading=eager referrerpolicy=strict-origin-when-cross-origin src="https://www.youtube.com/embed/ho0o7H6dXSU?autoplay=0&amp;controls=1&amp;end=0&amp;loop=0&amp;mute=0&amp;start=0" style=position:absolute;top:0;left:0;width:100%;height:100%;border:0 title="YouTube video"></iframe></div><p>Now obviously coding a whole fluid simulation with particles and forces was too much to do just for a silly visualization, so I decided on writing a simple force repellent simulation in Javascript.</p><p>I quickly then noticed that the performance, while manageable, wasn&rsquo;t fantastic, so I ended up writing the core logic again in Rust, and embedding it onto the page with WASM. This was quite a lot of fun, and the end result was a simulation more than twice as fast.</p><p>Now instead of just showing you the Rust one, I decided on making them interactive, with an FPS counter, and have them both be runnable in your browser. Make sure to pause the one you&rsquo;re not using at the time, so you can correctly assess the FPS differences!</p><h1 id=soap-sim-in-js>Soap sim in JS<a href=#soap-sim-in-js class=hanchor arialabel=Anchor>#</a></h1><script type=module src=/soap-sim/index-js.js></script><div id=js-canvas-container style=display:flex;justify-content:center;align-items:center><canvas id=js-canvas style=width:100%;height:auto>
Your browser does not support the canvas element.</canvas></div><div style=display:flex;justify-content:space-around;align-items:center;padding-top:1em><button id=js-simulate-button>Toggle JS simulation</button>
<button id=js-reset-button>Reset JS simulation</button></div><h1 id=soap-sim-in-wasm-rust>Soap sim in WASM (Rust)<a href=#soap-sim-in-wasm-rust class=hanchor arialabel=Anchor>#</a></h1><script type=module src=/soap-sim/index-wasm.js></script><div id=wasm-canvas-container style=display:flex;justify-content:center;align-items:center><canvas id=wasm-canvas style=width:100%;height:auto>
Your browser does not support the canvas element.</canvas></div><div style=display:flex;justify-content:space-around;align-items:center;padding-top:1em><button id=wasm-simulate-button>Toggle WASM simulation</button>
<button id=wasm-reset-button>Reset WASM simulation</button></div><h2 id=lessons-learned-during-this>Lessons learned during this<a href=#lessons-learned-during-this class=hanchor arialabel=Anchor>#</a></h2><p>When I first started working on the Rust WASM version, I initially expected a much bigger speedup, however after performance profiling the code, I learned that most of the work was not done by the logic in Javascript, but rather by the interaction with the DOM itself.
Because at the time of writing, there is no direct way from WASM (be it Rust, or your favourite language that can deploy to WASM) to interact with the DOM, it all has to go through Javascript. This meant that for my usecase at best (read as <code>never</code>) my Rust code would be as fast as Javascript while interacting with the DOM.</p><p>Now the second kicker: how do you tell Javascript where the grains of pepper are in your simulation? For me this is what my simulation State looked like in Rust:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>#[wasm_bindgen]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>State</span> {
</span></span><span style=display:flex><span>  circles: Vec<span style=color:#f92672>&lt;</span>Entity<span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span>  soaps: Vec<span style=color:#f92672>&lt;</span>Entity<span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span>  canvas_size: <span style=color:#66d9ef>f64</span>,
</span></span><span style=display:flex><span>  circle_size: <span style=color:#66d9ef>f64</span>,
</span></span><span style=display:flex><span>  repulsion_strength: <span style=color:#66d9ef>f64</span>,
</span></span><span style=display:flex><span>  positions: <span style=color:#a6e22e>Rc</span><span style=color:#f92672>&lt;</span>RefCell<span style=color:#f92672>&lt;</span>Vec<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>f64</span><span style=color:#f92672>&gt;&gt;&gt;</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Things like where the soap spots are, while being costly to transmit, are only done so maybe a couple of times over the whole lifespan of the simulation, whereas the thousands of pepper positions would need to jump from WASM to Javascript tens of times a second. So what gives? Well I ended up doing something I didn&rsquo;t know was possible in WASM before this, and that was sending over a pointer. Here is the Rust side:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>#[wasm_bindgen]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>impl</span> State {
</span></span><span style=display:flex><span>  <span style=color:#75715e>// other stuff...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>get_positions_ptr</span>(<span style=color:#f92672>&amp;</span>self) -&gt; <span style=color:#f92672>*</span><span style=color:#66d9ef>const</span> <span style=color:#66d9ef>f64</span> {
</span></span><span style=display:flex><span>    self.positions.borrow().as_ptr()
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>On the Javascript side then I would have to get the positions pointer from WASM, and then make a view into said array like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>positionsPtr</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>wasmState</span>.<span style=color:#a6e22e>get_positions_ptr</span>();
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>positions</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>Float64Array</span>(<span style=color:#a6e22e>wasmModule</span>.<span style=color:#a6e22e>memory</span>.<span style=color:#a6e22e>buffer</span>, <span style=color:#a6e22e>positionsPtr</span>, <span style=color:#a6e22e>numOfCircles</span> <span style=color:#f92672>*</span> <span style=color:#ae81ff>2</span>);
</span></span></code></pre></div><p>I find it interesting that we basically use the pointer as an offset in the buffer, and we tell it how long it is so we can have a mapping. From here on out, if I were to interact with the array on the Javascript side, it would modify it on the Rust side too!</p><p>Just to give an example of interaction from the other side, Javascript->Rust, here is how the state finds out about the new soap spots when the user taps/clicks on the screen. In Rust we have a receiver function:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>#[wasm_bindgen]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>impl</span> State {
</span></span><span style=display:flex><span>  <span style=color:#75715e>// other stuff...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>add_soap</span>(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> self, x: <span style=color:#66d9ef>f64</span>, y: <span style=color:#66d9ef>f64</span>) {
</span></span><span style=display:flex><span>	self.soaps.push(Entity::new(x, y, <span style=color:#ae81ff>0.0</span>, <span style=color:#ae81ff>0.0</span>));
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>And then on the Javascript side we have this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>handleTap</span> <span style=color:#f92672>=</span> (<span style=color:#a6e22e>event</span>) =&gt; {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>canvas</span> <span style=color:#f92672>=</span> document.<span style=color:#a6e22e>getElementById</span>(<span style=color:#e6db74>&#39;wasm-canvas&#39;</span>);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>mousePos</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>getTapPos</span>(<span style=color:#a6e22e>canvas</span>, <span style=color:#a6e22e>event</span>);
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>wasmState</span>.<span style=color:#a6e22e>add_soap</span>(<span style=color:#a6e22e>mousePos</span>.<span style=color:#a6e22e>x</span>, <span style=color:#a6e22e>mousePos</span>.<span style=color:#a6e22e>y</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=i-should-do-this-more-often>I should do this more often<a href=#i-should-do-this-more-often class=hanchor arialabel=Anchor>#</a></h3><p>I had a lot of fun working on this and now I can&rsquo;t help but wait for the day when WASM has full control over the DOM, imagine the performance!</p><p>This project has been a great learning experience, and it&rsquo;s always satisfying to see the final result come to life. I encourage you to take on similar challenges and explore new approaches to coding. Who knows, you might just discover a whole new way of thinking about a problem!</p><p>Until next time, happy coding!</p></div></div><div class=pagination><div class=pagination__title><span class=pagination__title-h>Read other posts</span><hr></div><div class=pagination__buttons><a href=/posts/scriptanchor/ class="button inline prev">&lt; [<span class=button__text>I wrote my Vision Pro killer app (Script Anchor)</span>]
</a>::
<a href=/posts/wsloom/ class="button inline next">[<span class=button__text>How to fix WSL2 crashing mid compile (Or any heavy IO)</span>] ></a></div></div></article></div><footer class=footer><div class=footer__inner><div class=copyright><span>© 2025 Powered by <a href=https://gohugo.io>Hugo</a></span>
<span>:: <a href=https://github.com/panr/hugo-theme-terminal target=_blank>Theme</a> made by <a href=https://github.com/panr target=_blank>panr</a></span></div></div></footer><script type=text/javascript src=/bundle.min.js></script></div></body></html>